open import Categories.Category
open import Categories.Category.CartesianClosed

open import Theory

module Categories.Category.Construction.Models
  {â„“â‚ â„“â‚‚ â„“â‚ƒ}
  (Th : Theory.Theory â„“â‚ â„“â‚‚ â„“â‚ƒ)
  {o â„“ e}
  (ğ’ : Category o â„“ e)
  (cartesianClosed : CartesianClosed ğ’)
  where

  open import Categories.Category.Cartesian ğ’
  open import Categories.Category.BinaryProducts ğ’
  open import Categories.Object.Terminal ğ’
  import Categories.Object.Product ğ’ as P
  open import Categories.Morphism ğ’
  open import Categories.Functor.Construction.Product using (Product)
  open import Categories.Functor.Construction.Exponential using (Exp)
  open import Categories.Functor.Properties using ([_]-resp-â‰…)

  open Category ğ’
  open CartesianClosed cartesianClosed
  open Cartesian cartesian
  open BinaryProducts products
  module T = Terminal terminal
  open HomReasoning
  open import Categories.Morphism.Reasoning ğ’

  open import Syntax
  open Theory.Theory Th
  open import Semantics ğ’ cartesianClosed Sg
  open Signature Sg

  open import Data.Product using (Î£; Î£-syntax; projâ‚; projâ‚‚; _,_)

  open import Relation.Binary using (Rel; IsEquivalence)

  open import Level using (_âŠ”_)

  â‚-id : forall {A B} -> id {A = A} â‚ id {A = B} â‰ˆ id
  â‚-id = Equiv.trans (âŸ¨âŸ©-congâ‚‚ identityË¡ identityË¡) Î·

  module Homomorphism {M N : Model ğ’ cartesianClosed Th}
    (h : (g : Gr) -> âŸ¦ g âŸ§G (projâ‚ M) â‰… âŸ¦ g âŸ§G (projâ‚ N))
    where
    open _â‰…_
    open Iso

    H : (A : Type) -> âŸ¦ A âŸ§T (projâ‚ M) â‰… âŸ¦ A âŸ§T (projâ‚ N)
    H âŒŠ g âŒ‹ = h g
    H Unit = up-to-iso terminal terminal
    H (A * Aâ‚) = [ Product ğ’ cartesian ]-resp-â‰…
      (record
        { from = from (H A) , from (H Aâ‚)
        ; to = to (H A) , to (H Aâ‚)
        ; iso = record { isoË¡ = isoË¡ (iso (H A)) , isoË¡ (iso (H Aâ‚)) ; isoÊ³ = isoÊ³ (iso (H A)) , isoÊ³ (iso (H Aâ‚)) }
        })
    H (A => Aâ‚) = [ Exp ğ’ cartesianClosed ]-resp-â‰…
      (record
        { from = from (H Aâ‚) , to (H A)
        ; to = to (H Aâ‚) , from (H A)
        ; iso = record { isoË¡ = isoË¡ (iso (H Aâ‚)) , isoË¡ (iso (H A)) ; isoÊ³ = isoÊ³ (iso (H Aâ‚)) , isoÊ³ (iso (H A)) }
        })

  record homomorphism (M N : Model ğ’ cartesianClosed Th) : Set (â„“â‚ âŠ” â„“â‚‚ âŠ” â„“ âŠ” e) where
    field
      h : (g : Gr) -> âŸ¦ g âŸ§G (projâ‚ M) â‰… âŸ¦ g âŸ§G (projâ‚ N)

    open Homomorphism {M} {N} h public

    field
      comm : (f : Func) -> _â‰…_.from (H (cod f)) âˆ˜ âŸ¦ f âŸ§F (projâ‚ M) â‰ˆ âŸ¦ f âŸ§F (projâ‚ N) âˆ˜ _â‰…_.from (H (dom f))

  module _ {M N : Model ğ’ cartesianClosed Th} where
    _â‰—_ : Rel (homomorphism M N) (â„“â‚ âŠ” e)
    _â‰—_ x y = (g : Gr) -> _â‰…_.from (homomorphism.h x g) â‰ˆ _â‰…_.from (homomorphism.h y g)

  module Id {M : Model ğ’ cartesianClosed Th} where
    open Homomorphism {M} {M} (Î» _ â†’ IsEquivalence.refl â‰…-isEquivalence)
    open Structure (projâ‚ M)

    -- The components of the homomorphism generated by identity morphisms are also identities.
    H-id : forall A -> _â‰…_.from (H A) â‰ˆ Category.id ğ’
    H-idË˜ : forall A -> _â‰…_.to (H A) â‰ˆ Category.id ğ’

    H-id âŒŠ x âŒ‹ = Equiv.refl
    H-id Unit = T.!-unique (Category.id ğ’)
    H-id (A * Aâ‚) =
      begin
        _â‰…_.from (H A) â‚ _â‰…_.from (H Aâ‚)
      â‰ˆâŸ¨ â‚-congâ‚‚ (H-id A) (H-id Aâ‚) âŸ©
        Category.id ğ’ â‚ Category.id ğ’
      â‰ˆâŸ¨ âŸ¨âŸ©-congâ‚‚ identityË¡ identityË¡ âŸ©
        âŸ¨ Ï€â‚ , Ï€â‚‚ âŸ©
      â‰ˆâŸ¨ Î· âŸ©
        Category.id ğ’
      âˆ
    H-id (A => Aâ‚) =
      begin
        Î»g (_â‰…_.from (H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ _â‰…_.to (H A)))
      â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆË¡ (H-id Aâ‚)) âŸ©
        Î»g (id âˆ˜ evalâ€² âˆ˜ (id â‚ _â‰…_.to (H A)))
      â‰ˆâŸ¨ Î»-cong (pullË¡ identityË¡) âŸ©
        Î»g (evalâ€² âˆ˜ (id â‚ _â‰…_.to (H A)))
      â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ Equiv.refl (H-idË˜ A))) âŸ©
        Î»g (evalâ€² âˆ˜ (id â‚ id))
      â‰ˆâŸ¨ Î»-cong (elimÊ³ â‚-id) âŸ©
        Î»g evalâ€²
      â‰ˆâŸ¨ Î·-idâ€² âŸ©
        id
      âˆ

    H-idË˜ âŒŠ x âŒ‹ = Equiv.refl
    H-idË˜ Unit = T.!-unique id
    H-idË˜ (A * Aâ‚) =
      begin
        _â‰…_.to (H A) â‚ _â‰…_.to (H Aâ‚)
      â‰ˆâŸ¨ â‚-congâ‚‚ (H-idË˜ A) (H-idË˜ Aâ‚) âŸ©
        id â‚ id
      â‰ˆâŸ¨ â‚-id âŸ©
        id
      âˆ
    H-idË˜ (A => Aâ‚) =
      begin
        Î»g (_â‰…_.to (H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ _â‰…_.from (H A)))
      â‰ˆâŸ¨ Î»-cong (elimË¡ (H-idË˜ Aâ‚)) âŸ©
        Î»g (evalâ€² âˆ˜ (id â‚ _â‰…_.from (H A)))
      â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ Equiv.refl (H-id A))) âŸ©
        Î»g (evalâ€² âˆ˜ (id â‚ id))
      â‰ˆâŸ¨ Î»-cong (elimÊ³ â‚-id) âŸ©
        Î»g evalâ€²
      â‰ˆâŸ¨ Î·-idâ€² âŸ©
        id
      âˆ

    comm : (f : Func) -> _â‰…_.from (H (cod f)) âˆ˜ âŸ¦ f âŸ§F â‰ˆ âŸ¦ f âŸ§F âˆ˜ _â‰…_.from (H (dom f))
    comm f =
      begin
        _â‰…_.from (H (cod f)) âˆ˜ âŸ¦ f âŸ§F
      â‰ˆâŸ¨ elimË¡ (H-id (cod f)) âŸ©
        âŸ¦ f âŸ§F
      â‰ˆË˜âŸ¨ elimÊ³ (H-id (dom f)) âŸ©
        âŸ¦ f âŸ§F âˆ˜ _â‰…_.from (H (dom f))
      âˆ

    idâ€² : homomorphism M M
    idâ€² = record { h = Î» _ â†’ IsEquivalence.refl â‰…-isEquivalence ; comm = comm }

  module Compose {M N O : Model ğ’ cartesianClosed Th} where
    open _â‰…_

    compose : homomorphism N O -> homomorphism M N -> homomorphism M O
    compose x y = record
      { h = h
      ; comm = Î» f â†’
          begin
            from (MO.H (cod f)) âˆ˜ âŸ¦ f âŸ§F (projâ‚ M)
          â‰ˆâŸ¨ pushË¡ (H-compose (cod f)) âŸ©
            from (NO.H (cod f)) âˆ˜ from (MN.H (cod f)) âˆ˜ âŸ¦ f âŸ§F (projâ‚ M)
          â‰ˆâŸ¨ âˆ˜-resp-â‰ˆÊ³ (MN.comm f) âŸ©
            from (NO.H (cod f)) âˆ˜ âŸ¦ f âŸ§F (projâ‚ N) âˆ˜ from (MN.H (dom f))
          â‰ˆâŸ¨ pullË¡ (NO.comm f) âŸ©
            (âŸ¦ f âŸ§F (projâ‚ O) âˆ˜ from (NO.H (dom f))) âˆ˜ from (MN.H (dom f))
          â‰ˆË˜âŸ¨ pushÊ³ (H-compose (dom f)) âŸ©
            âŸ¦ f âŸ§F (projâ‚ O) âˆ˜ from (MO.H (dom f))
          âˆ
      }
      where
        h = Î» g â†’ IsEquivalence.trans â‰…-isEquivalence (homomorphism.h y g) (homomorphism.h x g)
        module MO = Homomorphism h
        module MN = homomorphism y
        module NO = homomorphism x

        H-compose : forall A -> from (MO.H A) â‰ˆ from (NO.H A) âˆ˜ from (MN.H A)
        H-composeË˜ : forall A -> to (MO.H A) â‰ˆ to (MN.H A) âˆ˜ to (NO.H A)

        H-compose âŒŠ x âŒ‹ = Equiv.refl
        H-compose Unit = T.!-uniqueâ‚‚
        H-compose (A * Aâ‚) = Equiv.trans (â‚-congâ‚‚ (H-compose A) (H-compose Aâ‚)) (Equiv.sym â‚âˆ˜â‚)
        H-compose (A => Aâ‚) =
          begin
            Î»g (from (MO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MO.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆË¡ (H-compose Aâ‚)) âŸ©
            Î»g ((from (NO.H Aâ‚) âˆ˜ from (MN.H Aâ‚)) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MO.H A)))
          â‰ˆâŸ¨ Î»-cong assoc âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MO.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ Equiv.refl (H-composeË˜ A))))) âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A) âˆ˜ to (NO.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ secondâˆ˜second))) âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A)) âˆ˜ (id â‚ to (NO.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ assocÂ²') âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A))) âˆ˜ (id â‚ to (NO.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (pullË¡ Î²â€²)) âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (Î»g (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A))) â‚ id) âˆ˜ (id â‚ to (NO.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ â‚âˆ˜â‚)) âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (Î»g (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A))) âˆ˜ id â‚ id âˆ˜ to (NO.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ identityÊ³ identityË¡))) âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (Î»g (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A))) â‚ to (NO.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ identityË¡ identityÊ³))) âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id âˆ˜ Î»g (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A))) â‚ to (NO.H A) âˆ˜ id))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ â‚âˆ˜â‚)) âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (NO.H A)) âˆ˜ (Î»g (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A))) â‚ id))
          â‰ˆË˜âŸ¨ Î»-cong assocÂ²' âŸ©
            Î»g ((from (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (NO.H A))) âˆ˜ (Î»g (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A))) â‚ id))
          â‰ˆË˜âŸ¨ CartesianClosed.exp.subst cartesianClosed product product âŸ©
            Î»g (from (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (NO.H A))) âˆ˜ Î»g (from (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ to (MN.H A)))
          â‰ˆâŸ¨ Equiv.refl âŸ©
            from (NO.H (A => Aâ‚)) âˆ˜ from (MN.H (A => Aâ‚))
          âˆ

        H-composeË˜ âŒŠ x âŒ‹ = Equiv.refl
        H-composeË˜ Unit = T.!-uniqueâ‚‚
        H-composeË˜ (A * Aâ‚) = Equiv.trans (â‚-congâ‚‚ (H-composeË˜ A) (H-composeË˜ Aâ‚)) (Equiv.sym â‚âˆ˜â‚)
        H-composeË˜ (A => Aâ‚) =
          begin
            Î»g (to (MO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (MO.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆË¡ (H-composeË˜ Aâ‚)) âŸ©
            Î»g ((to (MN.H Aâ‚) âˆ˜ to (NO.H Aâ‚)) âˆ˜ evalâ€² âˆ˜ (id â‚ from (MO.H A)))
          â‰ˆâŸ¨ Î»-cong assoc âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (MO.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ Equiv.refl (H-compose A))))) âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A) âˆ˜ from (MN.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ secondâˆ˜second))) âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A)) âˆ˜ (id â‚ from (MN.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ assocÂ²') âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A))) âˆ˜ (id â‚ from (MN.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (pullË¡ Î²â€²)) âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (Î»g (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A))) â‚ id) âˆ˜ (id â‚ from (MN.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ â‚âˆ˜â‚)) âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (Î»g (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A))) âˆ˜ id â‚ id âˆ˜ from (MN.H A)))
          â‰ˆâŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ identityÊ³ identityË¡))) âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (Î»g (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A))) â‚ from (MN.H A)))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ (â‚-congâ‚‚ identityË¡ identityÊ³))) âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id âˆ˜ Î»g (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A))) â‚ from (MN.H A) âˆ˜ id))
          â‰ˆË˜âŸ¨ Î»-cong (âˆ˜-resp-â‰ˆÊ³ (âˆ˜-resp-â‰ˆÊ³ â‚âˆ˜â‚)) âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (MN.H A)) âˆ˜ (Î»g (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A))) â‚ id))
          â‰ˆË˜âŸ¨ Î»-cong assocÂ²' âŸ©
            Î»g ((to (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (MN.H A))) âˆ˜ (Î»g (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A))) â‚ id))
          â‰ˆË˜âŸ¨ CartesianClosed.exp.subst cartesianClosed product product âŸ©
            Î»g (to (MN.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (MN.H A))) âˆ˜ Î»g (to (NO.H Aâ‚) âˆ˜ evalâ€² âˆ˜ (id â‚ from (NO.H A)))
          â‰ˆâŸ¨ Equiv.refl âŸ©
            to (MN.H (A => Aâ‚)) âˆ˜ to (NO.H (A => Aâ‚))
          âˆ

  Models : Category (â„“â‚ âŠ” â„“â‚‚ âŠ” â„“â‚ƒ âŠ” o âŠ” â„“ âŠ” e) (â„“â‚ âŠ” â„“â‚‚ âŠ” â„“ âŠ” e) (â„“â‚ âŠ” e)
  Models = record
             { Obj = Model ğ’ cartesianClosed Th
             ; _â‡’_ = homomorphism
             ; _â‰ˆ_ = _â‰—_
             ; id = Id.idâ€²
             ; _âˆ˜_ = Compose.compose
             ; assoc = Î» _ â†’ assoc
             ; sym-assoc = Î» _ â†’ sym-assoc
             ; identityË¡ = Î» _ â†’ identityË¡
             ; identityÊ³ = Î» _ â†’ identityÊ³
             ; identityÂ² = Î» _ â†’ identityÂ²
             ; equiv = record { refl = Î» _ â†’ IsEquivalence.refl equiv ; sym = Î» x g â†’ IsEquivalence.sym equiv (x g) ; trans = Î» x xâ‚ g â†’ IsEquivalence.trans equiv (x g) (xâ‚ g) }
             ; âˆ˜-resp-â‰ˆ = Î» x xâ‚ g â†’ âˆ˜-resp-â‰ˆ (x g) (xâ‚ g)
             }
